# [상속과 구성](https://github.com/mini666/scala-edu/blob/master/src/main/scala/edu/scala/ch10/Element.scala)
## 2차원 레이아웃 라이브러리
## 추상 클래스
메서드의 경우 구현이 없으면 추상 메서드다.
## 파라미터 없는 메서드 정의
어떤 메서드가 인자도 받지 않고 메서드가 속한 객체의 변경 가능한 필드를 읽기만 하는 경우(객체의 상태를 변경하지 않는 경우)에는 파라미터 없는 메서드를 
사용하는 것이 관례이다. 
이러한 관례는 필드나 메서드 중 어떤 방식으로 속성을 정의하더라도 클라이언트 코드에는 영향을 끼치지 말아야 한다는 
**단일 접근 원칙**(uniform access principle)에 부합한다.
## 클래스 확장
## 메서드와 필드 오버라이드
스칼라에서는 필드와 메서드가 같은 네임스페이스에 속해 필드가 파라미터 없는 메서드를 오버라이드할 수 있다.  
자바에는 네가지 네임스페이스가 있다.
* 필드
* 메서드
* 타입
* 패키지

반면 스칼라에는 오직 두가지 네임스페이스만 있다.  
* 값(필드, 메서드, 패키지, 싱글톤 객체)
* 타입(클래스와 트레이트 이름)

스칼라가 필드와 메서드를 동일한 네임스페이스로 취급하는 이유는 정확히 파라미터 없는 메서드를 val로 오버라이드 하기 위해서이다.  
패키지도 필드 및 메서드 같은 네임스페이스를 공유하는 이유는 타입을 임포트하는 경우 외에도 싱글톤 객체의 필드와 메서드를 임포트할 수 있게 하기 위해서이다.
## 파라미터 필드 정의
클래스에 전달하는 인자를 val로 하면 동일한 이름의 파라미터와 필드를 동시에 정의하는 단축 표기다.
## 슈퍼클래스의 생성자 호출
```
class LineElement(s: String) extends ArrayElement(Array(s)) {
  override def width = s.length
  override def height = 1
}
```
ArrayElement의 생성자는 Array[String] 타입의 인자 하느를 받기때문에 LineElement는 슈퍼 클래스의 생성자에 인자를 하나 전달해야 한다. 
슈퍼 클래스의 생섲아를 호출하려면, 우너하는 인자를 슈퍼클래스 이름 뒤에 괄호로 묶어서 넘기면 된다.
## override 수식자 사용
부모 클래스에 있는 구체적(Concrete) 멤버를 오버라이드하는 모든 멤버에 override 수식자를 붙여야 한다. 하지만 추상 멤버를 구현할 경우에는 
override 수식자를 생략할 수 있다. 기반 클래스에 있는 멤버를 오버라이드하거나 구현하는 경우가 아니라면 override 수식자를 사용해서는 안된다.
## 다형성과 동적 바인딩
## final 멤버 선언
## 상속과 구성 사용
코드 재사용을 추가한다면, 상속보다는 구성을 선호할 것이다. 상속을 사용할 경우에는 깨지기 쉬운 기반 클래스 문제를 피할 수 없다. 
상속 관계가 **is-a** 관계를 모델링 한 것인지 질문해 본다. 또다른 질문은 코드를 사용하는 클라이언트 쪽에서 슈퍼클래스의 타입으로 서브클래스 
타입을 이용하길 원하는가이다.

## 팩토리 객체 정의
팩토리 객체를 사용하는 경우의 이점은 객체 생성 기능을 한 곳에 모아서 제공하고, 구체적인 내부 표현을 감출 수 있다는 것이다. 
이렇게 세부사항을 숨기면 클라이언트는 좀 더 쉽게 라이브러리를 이해할 수 있다. 또한 나중에 클라이언트의 코드를 깨제 않고 라이브러리 구현을 
변경하기에도 더 유리하다.

